# -*- coding: utf-8 -*-
"""224W_FinalProj_HypergraphIncidentMatrices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TLSe2QXr6JPM_Oco6LWglsEnh10rCQNO

# **CS224W - Final Project - Hypergraph Incidence and Adjacency Matrices**
> By Jay Liu and Sunwoo Kang

For our final project, we are implementing a fully connected graph neural network to learn node embeddings for a link prediction task. We were inspired by the MGCN paper to learn embeddings informed not only from local neighborhood structure, but from larger graph substructures. A 2-layer GNN can only capture information about the local 2-hop neighborhood of a node, but we can induce the network to capture extra information critical to the link prediction task by training layers on **hypergraphs** desgined to capture additional graph structual information.

In this colab, we detail the process of generating a **neighborhood-based hypergraph** for the OGB-DDI dataset. This hypergraph may be encoded as binary incidence matrix or an adjacency matrix (see our final report for definitions of each matrix). Theoretically, a similar process could be executed to generate anchor-based hypergraphs, centraility-based hypergraphs, or latent-feature based hypergraphs (the MGCN paper found that their link predicition model performed similarly using all the hypergraphs mentioned).
"""

# Install packages
!pip install -q torch-scatter -f https://pytorch-geometric.com/whl/torch-1.8.0+cu101.html
!pip install -q torch-sparse -f https://pytorch-geometric.com/whl/torch-1.8.0+cu101.html
!pip install -q torch-geometric
!pip install ogb

# Get Google SDK credentials
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# Authenticate and create the PyDrive client
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

"""# **Create the Hypergraph Incidence Matrix**

The hypergraph incidence matrix is a $VXV$ binary matrix, where $V=$ the total number of nodes in the orginal graph. Rows represent nodes and columns represent hyperedges. There is a $1$ in every $ij$ cell if node $j$ is in the $k-$hop neighborhood of node $i$ (and $0$ otherwise). (In other words, a hyperedge will exist between all nodes in the same k-hop neighborhood for each node.)
"""

# Import packages
import networkx as nx, pandas as pd, numpy as np
import math, torch
from torch.nn.parameter import Parameter
from torch.nn.modules.module import Module
import torch.nn.functional as F
import torch.nn as nn
import sys


from ogb.linkproppred import PygLinkPropPredDataset

device = 'cpu'
device = torch.device(device)

# Load ddi dataset
dataset = PygLinkPropPredDataset(name='ogbl-ddi',
                                  transform=T.ToSparseTensor())
data = dataset[0]
adj_t = data.adj_t.to(device)
split_edge = dataset.get_edge_split()

# Convert the OGB dataset to a NetworkX graph

dataset_G = PygLinkPropPredDataset(name = "ogbl-ddi", root = 'dataset/')
data_G = dataset_G[0]
G = nx.Graph()
G.add_nodes_from(range(data_G.num_nodes))
for i, (u, v) in enumerate(data_G.edge_index.t().tolist()):  
    G.add_edge(u, v)

# Get the k-hop neighborhood of all nodes

N_HOP = 4 # Can change this
neighbors = {}
for node in G.nodes:
  neighborhood = nx.single_source_shortest_path_length(G, node, cutoff=N_HOP)

  neighbors[node] = [node for node, length in neighborhood.items()
                    if length == N_HOP]

  print("Done with node ", node)

# Construct the hypergraph incident matrix.

num_nodes = data.num_nodes
theta = np.zeros((data.num_nodes, data.num_nodes))
for node in G.nodes:
  for kn in neighbors[node]:
    theta[node, kn] = 1

theta = torch.from_numpy(theta) # This is the hypergraph incident matrix!

# Save the hypergraph incident matrix.

import pickle

# save
with open('theta.pickle', 'wb') as handle:
    pickle.dump(theta, handle)

# Uncomment these lines to download theta to your local machine.
#from google.colab import files
#files.download('theta.pickle')

# open
with open('theta.pickle', 'rb') as handle:
    b = pickle.load(handle)

print(b)

"""# **Create the Hypergraph Adjacency Matrix**

The hypergraph adjacency matrix is a $VXV$ binary matrix, where $V=$ the total number of nodes in the orginal graph. 

Given a hypergraph $G^h = \{V, E^h\}$, let $\mathbf{H} \in \mathbb{R}^{|\mathcal{V}| \times\left|\mathcal{E}^{h}\right|}$ be an incidence matrix where each entry $\mathbf{H}(v,e)$ is defined as follows: 

$$\mathbf{H}(v, e)=\left\{\begin{array}{ll}
p(v, e), & \text { if } v \in e \\
0, & \text { otherwise }
\end{array}\right.$$

where $p(v, e)$ is the probability that node $v$ belongs to hyperedge $e$. Next, let the diagonal matrix $\mathbf{D}_{n} \in \mathbb{R}^{|\mathcal{V}| \times|\mathcal{V}|}$ store the degree of nodes in the hypergraph, such that $\mathrm{D}_{n}(v, v)=\sum_{e \in \mathcal{E}^{h}} \mathrm{H}(v, e)$. Since $H$ tracks the correlation between nodes and hyperedges, $\mathbf{H H}^{\top}$ quantifies the pairwise relationship between nodes in the hypergraph. Thus, the weighted adjacency matrix $\mathbf{A}_{h} \in \mathbb{R}^{|\mathcal{V}| \times|\mathcal{V}|}$ for hypergraph $G^h$ can be defined as:

$$\mathbf{A}_{\boldsymbol{h}}=\mathbf{H} \mathbf{H}^{\top}-\mathbf{D}_{\boldsymbol{n}}$$
"""

# Reload the hypergraph incidence matrix from Google Drive
from google.colab import drive
import pickle

drive.mount('/content/drive')
DATA_PATH = "/content/drive/MyDrive/cs224w_final"
infile = open(DATA_PATH + '/theta.pickle','rb')
theta = pickle.load(infile).double()

# Create the hypergraph adjacency matrix from the hypergraph incidence matrix.

D = np.zeros((theta.size()[0], theta.size()[1]))
theta_numpy = theta.numpy()
theta_sum = np.sum(theta_numpy, axis=1).tolist()
for idx, val in enumerate(theta_sum):
  D[idx, idx] = val

A_h = torch.mm(theta, theta.T)
A_h = A_h -D
theta = A_h
print(theta)